<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fwyan on </title>
    <link>http://blog.titangroupco.com/author/fwyan/index.xml</link>
    <description>Recent content in Fwyan on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [DevTeam](mailto:dev@titangroupco.com) of Titan.</copyright>
    <atom:link href="http://blog.titangroupco.com/author/fwyan/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>flask_cookie_based_session_mechanism</title>
      <link>http://blog.titangroupco.com/2017/03/15/flask_cookie_based_session_mechanism</link>
      <pubDate>Wed, 15 Mar 2017 16:34:27 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/03/15/flask_cookie_based_session_mechanism</guid>
      <description>&lt;h4 id=&#34;1-对cookie和session概念的理解&#34;&gt;1、对cookie和session概念的理解&lt;/h4&gt;

&lt;p&gt;引自维基百科上的两段话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在计算机科学领域来说，尤其是在网络领域，会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分。
在不包含会话层（例如UDP）或者是无法长时间驻留会话层（例如HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。&lt;/p&gt;

&lt;p&gt;因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么。 所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简言之，就是在基于HTTP协议的应用中，服务器每次响应客户端的请求，一是不知道是谁，二是不知道上次用户做了什么，而这两点是交互式web应用必须需要满足的需求，即服务器和客户端需要能够保持会话状态，session记录了服务端的会话状态，并借助cookie将服务端的会话状态传递至客户端，客户端通过cookie，将记录的会话状态再传递给服务端，服务端就能还原出上次会话现场了，这样就实现了服务端和客户端维持会话状态的目的。&lt;/p&gt;

&lt;h6 id=&#34;补充&#34;&gt;补充：&lt;/h6&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;cookie由相应的RFC6256定义相关规范和标准，是HTTP报文头部里实际存在的字段，常用的客户端，如浏览器都支持cookie，以及web server都支持cookie。&lt;/li&gt;
&lt;li&gt;个人理解session是web应用级别的解决方案，通常由web application实现（如果不需要也就不需要实现），常见的web框架一般都提供session功能模块&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;2-常见应用场景&#34;&gt;2、常见应用场景&lt;/h4&gt;

&lt;p&gt;客户端初次请求服务器端，服务端创建session对象，记录相关会话信息，同时给该session对象创建一个唯一性的session_id，然后在response响应头里设置set_cookie，将session_id的内容以cookie的方式发送到客户端，这样客户端就保存了session_id的内容在cookie里，后续客户端再访问服务端，请求头里就会自动带上cookie里的session_id，服务端从请求头里获取到session_id，通过session_id检索到响应的session对象，就能还原上次会话现场了。&lt;/p&gt;

&lt;p&gt;这里大家肯定会有疑问，这个session对象里存的什么内容，存放在哪里，session对象里要放什么内容，取决于具体应用的业务需求，完全可以自定义的，比如当前用户的相关信息，浏览器相关信息等，session的存放，通常有以下几种方案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务端的存储方案，session内容存放在服务端数据库，文件，缓存等，session_id存放客户端cookie&lt;/li&gt;
&lt;li&gt;客户端的存储方案，cookie based session，直接将session的内容通过set-cookie的方式，存到客户端去&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;注意&#34;&gt;注意：&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;为了达到保持会话状态的目的，虽然现在浏览器都支持cookie，但cookie不是100%的方案，因为cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面说了，cookie由RFC定义，不需要应用程序自身实现，基本上常见的客户端（浏览器）和服务器都支持cookie，而session则不同，session机制需要应用程序自身来实现（如果应用需要session的话），通常web框架都会提供各自的session方案。&lt;/p&gt;

&lt;h4 id=&#34;3-flask的cookie-based-session&#34;&gt;3、flask的cookie based session&lt;/h4&gt;

&lt;p&gt;Flask自带的session模块，实现的是上述第第二种方案，cookie based session。&lt;/p&gt;

&lt;p&gt;Flask app启动时，会创建一个全局的session对象，可以在app的请求上下文中访问到，结构类似于字典，可以根据业务需要在session里面添加自定义键值对，http请求返回时，通过set-cookie将整个session对象，写到客户端的cookie里，因为cookie里只能存放文本字符串，而session对象通常是有一定的组织结构的数据对象，所以需要在服务端经过一系列的转换之后，比如序列化，编码，签名等操作后，得到的一个字符串，才能以set-cookie的方式写到客户端。&lt;/p&gt;

&lt;p&gt;将session对象成功写入客户端cookie后，后续客户端的请求就会自动带上该cookie，服务端从请求头里检索出cookie的内容，就获得了上次请求时创建的session对象，经过解码，验证签名，反序列化之后，既可得到服务端格式的session对象，写cookie和读取cookie的流程如下图所示：
&lt;img src=&#34;http://blog.titangroupco.com/img/flask_cookie_based_session.png&#34; alt=&#34;flask_cookie_based_session&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图红色箭头标注的过程，是session对象转换成cookie格式字符串的过程，详细过程包括以下几个步骤，如下图所示：
&lt;img src=&#34;http://blog.titangroupco.com/img/flask_session_cookie_gen.png&#34; alt=&#34;flask_session_cookie_gen&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同样，解析cookie_session的过程，就是上述过程的逆过程，生成和解析验证cookie_session的过程都由服务器端完成，客户端负责存储和捎带。&lt;/p&gt;

&lt;h6 id=&#34;补充-1&#34;&gt;补充：&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;HMACSHA1 是从 SHA1 哈希函数构造的一种键控哈希算法，被用作 HMAC（基于哈希的消息验证代码）。 此 HMAC 进程将密钥与消息数据混合，使用哈希函数对混合结果进行哈希计算，将所得哈希值与该密钥混合，然后再次应用哈希函数。 输出的哈希值长度为 160 位。
HMAC 可用于确定通过不安全信道发送的消息是否已被篡改。 发送方计算原始数据的哈希值，并将原始数据和哈希值放在一个消息中同时传送。 接收方重新计算所接收消息的哈希值，并检查计算所得的 HMAC 是否与传送的 HMAC 匹配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;cookie的安全措施&#34;&gt;cookie的安全措施：&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;通过设置httponly标识，保证存放在客户端里的session内容不会被js访问到，杜绝了xss攻击，flask的session_cookie默认是设置了httpOnly标识的。&lt;/li&gt;
&lt;li&gt;通过添加签名，防止了session被恶意篡改，如果在客户端里把session里的用户认证信息修改成他人，想冒充他人身份访问服务器，是验证不通过的，因为验证签名不可能通过，除非你同时知道了签名秘钥secrect_key，而这个是服务端配置的，是极不可能被盗取的。flask的session采用HMACSHA1对发送到客户端的session_cookie做了签名。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;4-flask-login对cookie-based-session的应用&#34;&gt;4、flask_login对cookie_based_session的应用&lt;/h4&gt;

&lt;p&gt;经过前面的阐述，我们对session，cookie概念，以及cookie base session机制有了比较清晰的认识了，然后我们实际的业务需求哪些可以基于这些技术来实现呢，我们通常有哪些信息cookie里，需要经常发送给服务端的数据就非常适合存放在cookie里面，比如身份认证信息，为了避免每次访问都要认证用户身份，可以将用户身份信息存储在cookie里，这样每次客户端访问服务器时，会自动捎带身份信息到服务端。&lt;/p&gt;

&lt;p&gt;flask_login就是基于flask的cookie base session提供用户登录登出的功能的一个比较实用的插件。&lt;/p&gt;

&lt;p&gt;flask_login插件使用起来是非常简单的，主要核心的几个方法：&lt;/p&gt;

&lt;h6 id=&#34;1-login-user方法&#34;&gt;1、login_user方法&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;
def login_user(user, remember=False, force=False, fresh=True):
    &#39;&#39;&#39;
    ......
    &#39;&#39;&#39;

    user_id = getattr(user, current_app.login_manager.id_attribute)()
    session[&#39;user_id&#39;] = user_id
    session[&#39;_fresh&#39;] = fresh
    session[&#39;_id&#39;] = _create_identifier()
    &#39;&#39;&#39;
    ......
    &#39;&#39;&#39;
    return True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户登录时，提交了用户名和密码，flask验证了用户名和密码ok后，调用该方法，传递一个user对象，就成功将用户身份信息（user_id）写入了session，然后返回写入到了浏览器的cookie里，用户后续访问，flask就能从session对象里的user_id来加载用户，在flask的上下文环境下，维持一个当前用户对象，current_user对象。&lt;/p&gt;

&lt;h6 id=&#34;2-get-id方法&#34;&gt;2、get_id方法&lt;/h6&gt;

&lt;p&gt;前面提到了用户身份信息user_id，这个属性可以自定义，通常采用具有唯一性的用户属性来定义user_id，比如用户id，user_name等唯一性属性。通过定义get_id方法来返回user_id即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def get_id(self):
    return six.text_type(self.username)

&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;3-user-loader装饰器和current-user对象&#34;&gt;3、user_loader装饰器和current_user对象&lt;/h6&gt;

&lt;p&gt;flask应用需要定义一个方法，加上flask_login的user_loader装饰器，该方法根据user_id检索用户，返回一个user对象，这个user对象就是上下文里的current_user对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@login_manager.user_loader
def user_loader(username):
    user = db.User.get_user_by_name(username)
    if not user:
        return
    return user
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;4-login-required装饰器&#34;&gt;4、login_required装饰器&lt;/h6&gt;

&lt;p&gt;对于某些需要登录才能访问的API，添加该装饰器即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@login_required
    def get_alerts(self):
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;5-login-out方法&#34;&gt;5、login_out方法&lt;/h6&gt;

&lt;p&gt;退出登录，主要工作就是将session里的相关身份信息清空，如user_id等，session更新了，response通过set-cookie同步也更新了客户端cookie里的session内容。&lt;/p&gt;

&lt;h6 id=&#34;附注&#34;&gt;附注：&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;你可能记得不太清楚的cookie细节，推荐下面这篇文章，梳理了很多cookie相关细节知识点，比如expire，domain和path，secure属性，HttpOnly属性，服务端和客户端设置cookie有哪些不同等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000004556040&#34;&gt;https://segmentfault.com/a/1190000004556040&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;参考&#34;&gt;参考：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Cookie&#34;&gt;https://zh.wikipedia.org/wiki/Cookie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265&#34;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>D3 入门教程</title>
      <link>http://blog.titangroupco.com/2017/01/24/d3-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B</link>
      <pubDate>Tue, 24 Jan 2017 16:50:51 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/01/24/d3-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B</guid>
      <description>&lt;h1 id=&#34;1-数据可视化&#34;&gt;1. 数据可视化&lt;/h1&gt;

&lt;p&gt;数据可视化，是关于数据视觉表现形式的科学技术研究。为了使复杂的数据和文字变得更容易理解，各种可视化工具因此诞生，其中D3 正是其中的佼佼者。
&lt;img src=&#34;http://www.ourd3js.com/wordpress/wp-content/uploads/2014/06/14.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-d3-简介&#34;&gt;2. D3 简介&lt;/h1&gt;

&lt;p&gt;D3 的全称是（Data-Driven Documents），字面意思是一个被数据驱动的文档。听名字有点抽象，说简单一点，其实就是一个 JavaScript 的函数库，使用它主要是用来做数据可视化的。&lt;/p&gt;

&lt;h1 id=&#34;3-基本用法&#34;&gt;3. 基本用法&lt;/h1&gt;

&lt;h2 id=&#34;3-1-选择元素&#34;&gt;3.1 选择元素&lt;/h2&gt;

&lt;p&gt;在 D3 中，用于选择元素的函数有两个，函数接收符合CSS选择器条件的字符串：
- d3.select()：是选择所有指定元素的第一个
- d3.selectAll()：是选择指定元素的全部&lt;/p&gt;

&lt;p&gt;这两个函数返回的结果称为选择集。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-2-绑定数据&#34;&gt;3.2 绑定数据&lt;/h2&gt;

&lt;p&gt;D3 有一个很独特的功能：能将数据绑定到 DOM 上，绑定之后，当需要依靠这个数据才操作元素的时候，会很方便。&lt;/p&gt;

&lt;p&gt;D3 中是通过以下两个函数来绑定数据的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;datum()：绑定一个数据到选择集上&lt;/li&gt;
&lt;li&gt;data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相对而言，data() 比较常用。&lt;/p&gt;

&lt;h2 id=&#34;3-3-插入元素&#34;&gt;3.3 插入元素&lt;/h2&gt;

&lt;p&gt;插入元素涉及的函数有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;append()：在选择集末尾插入元素&lt;/li&gt;
&lt;li&gt;insert()：在选择集前面插入元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-4-删除元素&#34;&gt;3.4 删除元素&lt;/h2&gt;

&lt;p&gt;对于选择的元素，使用remove()函数&lt;/p&gt;

&lt;h2 id=&#34;3-5-比例尺&#34;&gt;3.5 比例尺&lt;/h2&gt;

&lt;p&gt;将某一区域的值映射到另一区域，其大小关系不变。&lt;/p&gt;

&lt;p&gt;比例尺，很像数学中的函数。例如，对于一个一元二次函数，有 x 和 y 两个未知数，当 x 的值确定时，y 的值也就确定了。&lt;/p&gt;

&lt;p&gt;在数学中，x 的范围被称为定义域，y 的范围被称为值域。&lt;/p&gt;

&lt;p&gt;D3 中的比例尺，也有定义域和值域，分别被称为 domain 和 range。开发者需要指定 domain 和 range 的范围，如此即可得到一个计算关系。&lt;/p&gt;

&lt;p&gt;D3 提供了多种比例尺，常用的有以下两种：
- d3.scale.linear()：返回一个线性的比例尺，能将一个连续的区间，映射到另一区间。
- d3.scale.ordinal()：返回一个序数比例尺，即定义域和值域是离散的。&lt;/p&gt;

&lt;h2 id=&#34;3-6-坐标轴&#34;&gt;3.6 坐标轴&lt;/h2&gt;

&lt;p&gt;坐标轴，是可视化图表中经常出现的一种图形，由一些列线段和刻度组成。在D3 中使用d3.svg.axis()，能够在 SVG 中生成组成坐标轴的元素。&lt;/p&gt;

&lt;h1 id=&#34;4-实现一个简单的柱形图&#34;&gt;4. 实现一个简单的柱形图&lt;/h1&gt;

&lt;p&gt;一个完整的柱形图包含三部分：矩形、文字、坐标轴。基于D3 的基本用法，制作一个简单的柱形图，内容包括：选择集、数据绑定、比例尺、坐标轴等内容。&lt;/p&gt;

&lt;h2 id=&#34;4-1-添加-svg-画布&#34;&gt;4.1 添加 SVG 画布&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//画布大小
var width = 400;
var height = 400;

//在 body 里添加一个 SVG 画布   
var svg = d3.select(&amp;quot;body&amp;quot;)
    .append(&amp;quot;svg&amp;quot;)
    .attr(&amp;quot;width&amp;quot;, width)
    .attr(&amp;quot;height&amp;quot;, height);

//画布周边的空白
 var padding = {left:30, right:30, top:20, bottom:20};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了一个 padding，是为了给 SVG 的周边留一个空白，最好不要将图形绘制到边界上。&lt;/p&gt;

&lt;h2 id=&#34;4-2-定义数据和比例尺&#34;&gt;4.2 定义数据和比例尺&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//定义一个数组
var dataset = [10, 20, 30, 40, 33, 24, 12, 5];

//x轴的比例尺
var xScale = d3.scale.ordinal()
    .domain(d3.range(dataset.length))
    .rangeRoundBands([0, width - padding.left - padding.right]);

//y轴的比例尺
var yScale = d3.scale.linear()
    .domain([0,d3.max(dataset)])
    .range([height - padding.top - padding.bottom, 0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x 轴使用序数比例尺，y 轴使用线性比例尺。要注意两个比例尺值域的范围。&lt;/p&gt;

&lt;h2 id=&#34;4-3-定义坐标轴&#34;&gt;4.3 定义坐标轴&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//定义x轴
var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient(&amp;quot;bottom&amp;quot;);

//定义y轴
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient(&amp;quot;left&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x 轴刻度的方向向下，y 轴的向左。&lt;/p&gt;

&lt;h2 id=&#34;4-4-添加矩形和文字元素&#34;&gt;4.4 添加矩形和文字元素&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//矩形之间的空白
var rectPadding = 4;

//添加矩形元素
var rects = svg.selectAll(&amp;quot;.MyRect&amp;quot;)
        .data(dataset)
        .enter()
        .append(&amp;quot;rect&amp;quot;)
        .attr(&amp;quot;class&amp;quot;,&amp;quot;MyRect&amp;quot;)
        .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + padding.top + &amp;quot;)&amp;quot;)
        .attr(&amp;quot;x&amp;quot;, function(d,i){
            return xScale(i) + rectPadding/2;
        } )
        .attr(&amp;quot;y&amp;quot;,function(d){
            return yScale(d);
        })
        .attr(&amp;quot;width&amp;quot;, xScale.rangeBand() - rectPadding )
        .attr(&amp;quot;height&amp;quot;, function(d){
            return height - padding.top - padding.bottom - yScale(d);
        });

//添加文字元素
var texts = svg.selectAll(&amp;quot;.MyText&amp;quot;)
        .data(dataset)
        .enter()
        .append(&amp;quot;text&amp;quot;)
        .attr(&amp;quot;class&amp;quot;,&amp;quot;MyText&amp;quot;)
        .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + padding.top + &amp;quot;)&amp;quot;)
        .attr(&amp;quot;x&amp;quot;, function(d,i){
            return xScale(i) + rectPadding/2;
        } )
        .attr(&amp;quot;y&amp;quot;,function(d){
            return yScale(d);
        })
        .attr(&amp;quot;dx&amp;quot;,function(){
            return (xScale.rangeBand() - rectPadding)/2;
        })
        .attr(&amp;quot;dy&amp;quot;,function(d){
            return 20;
        })
        .text(function(d){
            return d;
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;矩形元素和文字元素的 x 和 y 坐标要特别注意，要结合比例尺给予适当的值。&lt;/p&gt;

&lt;h2 id=&#34;4-5-添加坐标轴的元素&#34;&gt;4.5 添加坐标轴的元素&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//添加x轴
svg.append(&amp;quot;g&amp;quot;)
  .attr(&amp;quot;class&amp;quot;,&amp;quot;axis&amp;quot;)
  .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + (height - padding.bottom) + &amp;quot;)&amp;quot;)
  .call(xAxis);

//添加y轴
svg.append(&amp;quot;g&amp;quot;)
  .attr(&amp;quot;class&amp;quot;,&amp;quot;axis&amp;quot;)
  .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + padding.top + &amp;quot;)&amp;quot;)
  .call(yAxis);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-6-完整效果图&#34;&gt;4.6 完整效果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.ourd3js.com/wordpress/wp-content/uploads/2014/06/5111.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;5-结语&#34;&gt;5. 结语&lt;/h1&gt;

&lt;p&gt;使用D3 可以方便的实现各种可视化效果，它与其他可视化工具的主要区别如下：
&lt;img src=&#34;http://wiki.jikexueyuan.com/project/d3wiki/images/layout-2.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择 D3：如果希望开发脑海中任意想象到的图表；&lt;/li&gt;
&lt;li&gt;选择 Highcharts、Echarts 等：如果希望开发几种固定种类的、十分大众化的图表。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>前端使用websocket的问题</title>
      <link>http://blog.titangroupco.com/2017/01/22/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8websocket%E7%9A%84%E9%97%AE%E9%A2%98</link>
      <pubDate>Sun, 22 Jan 2017 18:11:48 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/01/22/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8websocket%E7%9A%84%E9%97%AE%E9%A2%98</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;websocket相关概念&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&#34;&gt;websocket&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。
IE10以上才支持HTML5，才支持websocket，chrome，火狐，opera等浏览器支持较好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://socket.io/&#34;&gt;Socket.IO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了&lt;strong&gt;客户端的JavaScript&lt;/strong&gt;和&lt;strong&gt;服务器端的Node.js&lt;/strong&gt;。
Socket.IO是一个跨平台，支持多种连接方式，如websocket，flashsocket,ajax等，如果客户端不支持websocket时，可以切换使用其他链接方式，比如ajax轮询等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;/lib/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
   var socket = io();
   socket.on(&#39;connect&#39;, function() {
           /* 具体操作 */
   });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最近笔者新参与的一个web项目，拟定采用vue2.0来编写，期间遇到有关使用websocket的问题，记录一下，个中遇到的一些问题和解决方法，分享给有需要的人。&lt;/p&gt;

&lt;p&gt;当前服务端采用了websocket的方式，这需要客户端也相应的采用websocket来与客户端建立ws连接，这样客户端和服务端就可以双向的发送数据。笔者当时一拿到这个就会觉得是不是又需要npm安装什么包似的，因为这个功能是从另一个项目（暂且称其为项目B）的功能迁移过来的，而项目B前端是用的angularjs开发的，前端直接用的angularjs的一个websocket的包（angular-websocke），然后几行代码就敲定了，创建连接，发送数据，接收数据，很是方便。当前项目采用的是vue框架，很自然的就去搜有木有vue的websocket包，很快找到了vue-websocket，安装好后，调试，直接报错：
　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=polling&amp;amp;t=LbjddEK. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://localhost:8080&#39; is therefore not allowed access. The response had HTTP status code 404.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;笔者对比了项目B，同样在客户端启动本地server，能正常创建到服务端的ws连接，不会像http请求一样有跨域的问题，同时另一问题就是，明明是要创建ws连接，为何浏览器的控制台里会提示是http的连接？vue-websocket没有调试成功，马上去找找有没有通用的包，于是在github找了js相关的websocket的相关包，比如ws，笔者对照了angularjs-websocket包，它也是依赖的ws。于是按照ws的说明文档，安装，然后webpack直接报错了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR in ./~/ws/lib/WebSocketServer.js
Module not found: Error: Cannot resolve module &#39;tls&#39; in xx\node_modules\ws\lib
@ ./~/ws/lib/WebSocketServer.js 15:10-24
ERROR in ./~/options/lib/options.js
Module not found: Error: Cannot resolve module &#39;fs&#39; in xx\node_modules\options\lib
@ ./~/options/lib/options.js 6:9-22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找资料，说是这两个包是服务端node用的，客户端没有所以导致报错，需要修改webpack的配置文件，使其不加载客户端不需要的包
&lt;a href=&#34;https://github.com/webpack/react-starter/issues/3#issuecomment-53395089&#34;&gt;https://github.com/webpack/react-starter/issues/3#issuecomment-53395089&lt;/a&gt;
然后，webpack不报错了，但是前端调用ws生成实例的时候，依然会报错，因为ws链接创建的时候，先发起了http的链接请求，按照ws文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var WebSocket = require(&#39;ws&#39;)
var ws = new WebSocket(&#39;ws://xxx/ws&#39;, &#39;ws&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码里，生成ws实例的时候，还是会产生http的链接，跟前面用vue-websocket的情况类似，因为是在本地启动的前端服务，所以这样发起到服务器的请求，会导致跨越报错。奇怪的是项目B里的angular使用的angular-websocket包，同样是基于ws包做的，在本地启动，是直接创建的ws链接，没有跨越的问题。然后在vue论坛上查找相关资料，类似的问题比如：&lt;a href=&#34;https://forum-archive.vuejs.org/topic/1293/webpack-bundling-issue-with-websockets/3&#34;&gt;https://forum-archive.vuejs.org/topic/1293/webpack-bundling-issue-with-websockets/3&lt;/a&gt;
有人提到：Can&amp;rsquo;t you just use window.WebSocket instead of ws?
提醒到了我，我摒弃了ws，直接用window.WebSocket，来创建ws连接，果然成功了。那为啥angular-websocket基于ws，能正常在浏览器执行，vue这边直接用ws不行，于是去查看angular-websocket的源码，才发现angular-websocket基于ws做了封装，它提供的$websocket对象，在当前浏览器环境下，本质上也是window.WebSocket的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import angular from &#39;angular&#39;;
var Socket;
if (typeof window === &#39;undefined&#39;) {
try {
var ws = require(&#39;ws&#39;);
Socket = (ws.Client||ws.client||ws);
} catch(e) {}
}
// Browser
Socket = (Socket || window.WebSocket || window.MozWebSocket);
////////////////////////////////////////////////////////////
function $WebSocketBackendProvider($log) {
this.create = function create(url, protocols) {
var match = /wss?:\/\//.exec(url);
if (!match) {
throw new Error(&#39;Invalid url provided&#39;);
}
if (protocols) {
return new Socket(url, protocols);
}
return new Socket(url);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看源码里面，angular-websocket也是用window.WebSocket创建的，只有在没有window对象的时候，才会基于ws包来创建websocket对象。然后瞬间感觉找准了方向，目前我们的场景主要是PC端的浏览器使用，可以直接用window.WebSocket对象来，于是查阅了&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&#34;&gt;window.WebSocket的文档&lt;/a&gt;，很快问题就解决了，原来自带的window对象就已经可以解决问题了，自己绕了一大圈，还是回到原点，细看了它文档里写的相关方法，确实和前面讲到的angular-websocket很像，确实angular-websocket是对这些方法，比如onopen，send，onmessange等方法进行了封装，让开发可以更方便的调用。&lt;/p&gt;

&lt;p&gt;另外，文章最前面提到的&lt;a href=&#34;http://socket.io/&#34;&gt;Socket.IO&lt;/a&gt;，笔者在客户端安装了Socket.IO，并且按照文档说明，去建立ws链接，发现以下问题：&lt;/p&gt;

&lt;h4 id=&#34;1-安装socket-io-client-安装完之后-webpack报错&#34;&gt;1、安装socket.io-client，安装完之后，webpack报错&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;ERROR in ./~/socket.io-client/~/component-emitter/index.js
Module build failed: Error: ENOENT: no such file or directory, open &#39;xx\node_modules\socket.io-client\node_modules\component-emitter\index.js&#39;
    at Error (native)
 @ ./~/socket.io-client/lib/manager.js 8:14-42
ERROR in ./~/engine.io-client/~/component-emitter/index.js
Module build failed: Error: ENOENT: no such file or directory, open &#39;xx\node_modules\engine.io-client\node_modules\component-emitter\index.js&#39;
    at Error (native)
 @ ./~/engine.io-client/lib/socket.js 6:14-42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;https://github.com/socketio/socket.io-client/issues/933&#34;&gt;https://github.com/socketio/socket.io-client/issues/933&lt;/a&gt;这个需要修改一下webpack的配置文件，添加以下两行后，webpack可以打包通过。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module: {
    noParse: [&#39;ws&#39;]
  },
  externals: [&#39;ws&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-创建连接报错&#34;&gt;2、创建连接报错&lt;/h4&gt;

&lt;p&gt;创建连接&lt;code&gt;var socket = io(url);&lt;/code&gt;，这样创建的链接，Socket.IO默认是按轮询方式发起的http请求（很奇怪，当前浏览器明明是支持websocket的），这样首先就出现了前面的http跨域请求报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=polling&amp;amp;t=LbjddEK. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://localhost:8080&#39; is therefore not allowed access. The response had HTTP status code 404.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查阅资料，创建连接的时候，可以指定参数&lt;code&gt;io(WS_URL, {transports: [&#39;websocket&#39;, &#39;polling&#39;, &#39;flashsocket&#39;]})&lt;/code&gt;，设置其发起websocket链接，这样在console里看到的确实是发起的ws请求，然而依然报404错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WebSocket connection to &#39;ws://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=websocket&#39; failed: Error during WebSocket handshake: Unexpected response code: 404
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示是404找不到，确实是服务端没有&lt;code&gt;&#39;ws://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=websocket&#39;&lt;/code&gt;这样的url，这种url是默认的ws服务端的url，可以设置 path，path默认是&lt;code&gt;/socket.io&lt;/code&gt;，设置path后，&lt;code&gt;io(WS_URL, {path: &#39;/ws&#39;, transports: [&#39;websocket&#39;, &#39;polling&#39;, &#39;flashsocket&#39;]})&lt;/code&gt;，依然报301错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WebSocket connection to &#39;ws://192.168.0.239:9000/ws/?EIO=3&amp;amp;transport=websocket&#39; failed: Error during WebSocket handshake: Unexpected response code: 301
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;笔者对比了成功建立ws链接时的url，&lt;code&gt;ws://192.168.0.239:9000/ws&lt;/code&gt;，然后用工具测试了下，只有path是&lt;code&gt;/ws&lt;/code&gt;，即ws://192.168.0.239:9000/ws?EIO=3&amp;amp;transport=websocket&lt;code&gt;这样的url才能成功建立ws链接，这里报301的错误，是因为socketio会在path后面添加&lt;/code&gt;/?EIO=3&amp;amp;transport=websocket`这样一串参数，这样导致了服务端路由匹配不上，导致出现了404或301的情况，所以这里需要服务端配合调整一下路由规则，即可。&lt;/p&gt;

&lt;p&gt;最终，结合当前的实际情况还是采用了原生的websocket，Socket.IO对url的格式有一定的规范要求，目前查阅了socketio的相关api文档，尚未找到可以自定义url格式的方法，比较适合客户端和服务端都同时可控的情况。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>