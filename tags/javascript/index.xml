<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on </title>
    <link>http://blog.titangroupco.com/tags/javascript/index.xml</link>
    <description>Recent content in Javascript on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [DevTeam](mailto:dev@titangroupco.com) of Titan.</copyright>
    <atom:link href="http://blog.titangroupco.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>javascript events</title>
      <link>http://blog.titangroupco.com/2017/03/03/javascript-events</link>
      <pubDate>Fri, 03 Mar 2017 10:34:39 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/03/03/javascript-events</guid>
      <description>&lt;h1 id=&#34;javascript事件机制&#34;&gt;JavaScript事件机制&lt;/h1&gt;

&lt;p&gt;事件是实现页面交互的常用手段，在浏览器环境下的事件主要由DOM、BOM事件类型组成。&lt;/p&gt;

&lt;h2 id=&#34;一-什么是事件&#34;&gt;一、什么是事件&lt;/h2&gt;

&lt;p&gt;事件就是文档、浏览器窗口中发生的一些特定的交互瞬间，一般是由用户主动触发，在事件被触发之后，可以根据是否预先绑定了事件处理程序来决定如何对这个事件的发生做出反应。
&lt;/p&gt;

&lt;h2 id=&#34;二-事件流&#34;&gt;二、事件流&lt;/h2&gt;

&lt;p&gt;事件流是指页面中的元素、节点接收某一个被触发的事件的顺序。分为事件冒泡、事件捕获和DOM事件流。
IE和Netscape的浏览器开发团队提出了两种截然不同的，甚至是完全相反的事件流概念。IE的事件流是事件冒泡，而Netscape的事件流是事件捕获。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事件冒泡：事件发生后，由目标元素首先接收，然后按照DOM结构，逐级向上传播，直至到达最顶层的根节点document&lt;/li&gt;
&lt;li&gt;事件捕获：事件发生后，由根节点document先接收，然后按照DOM结构，逐级向下传播，直到事件的目标元素&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DOM事件流：包括三个阶段：当一个事件发生，首先进入事件捕获阶段，按照事件捕获流进行传播；然后进入目标阶段，目标元素接收到事件；最后进入事件冒泡阶段，按照事件冒泡流传播。&lt;img src=&#34;http://7xi480.com1.z0.glb.clouddn.com/121ba0d37798d6d23227d2dd49d0e58c_articlex.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-基础事件操作&#34;&gt;三、基础事件操作&lt;/h2&gt;

&lt;h3 id=&#34;1-事件监听&#34;&gt;1、事件监听&lt;/h3&gt;

&lt;p&gt;浏览器会根据某些操作触发对应事件，比如我们打开一个页面，浏览器加载完成之后就会触发load事件。当我们监听load事件，显示欢迎信息，那么浏览器在加载完成后就会显示欢迎信息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;html内联属性：HTML元素里面直接填写与事件有关属性，属性值为JavaScript代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button onclick=&amp;quot;alert(&#39;you clicked this btn&#39;)&amp;quot;&amp;gt;click me！&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DOM属性绑定：使用DOM元素的onXXX属性设置，简单易懂，兼容性好，但是如果在后面的代码中再次为ele绑定一个回调函数，会覆盖掉之前回调函数的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;click me!&amp;lt;/button&amp;gt;
   &amp;lt;script&amp;gt;
       var ele = document.getElementById(&#39;btn&#39;);
       ele.onclick = function (event) {
           alert(&#39;you clicked again&#39;);
       }
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用事件监听函数：标准的事件监听函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;element.addEventListener(event-name,callback,use-capture)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在element这个对象上面添加一个事件监听器，当监听到有事件发生时，调用这个回调函数，use-capture表示该事件监听是在‘捕获’阶段监听（设置为true）还是在‘冒泡’阶段监听（设置为false）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button&amp;gt;click me!&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
    var ele = document.getElementByTagName(&#39;button&#39;);
    ele[0].addEventListener(&#39;click&#39;, function () {
        alert(&#39;the third time clicked&#39;);
    }, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-移除事件监听&#34;&gt;2、移除事件监听&lt;/h3&gt;

&lt;p&gt;当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;element.removeEventListener(event-name,callback,use-capture)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;click me&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
var elbtn = document.getElementById(&#39;btn&#39;);
var fun = function () {
    alert(this button is only can click once);
    elbtn.removeEventListener(&#39;click&#39;, fun, false);
};
elbtn.addEventListener(&#39;click&#39;, fun, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;window事件&#34;&gt;window事件&lt;/h1&gt;

&lt;h2 id=&#34;常用的window事件&#34;&gt;常用的window事件&lt;/h2&gt;

&lt;p&gt;例子：&lt;a href=&#34;https://jsfiddle.net/uujt1o1p/&#34;&gt;https://jsfiddle.net/uujt1o1p/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;h3 id=&#34;onload加载事件和onunload卸载事件&#34;&gt;onload加载事件和onunload卸载事件&lt;/h3&gt;

&lt;p&gt;当页面完全加载之后触发加载事件（onload）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.onload = function () {
  alert(&amp;quot;here is after  onload&amp;quot;);
}
alert(&#39;onloading...&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当页面完全卸载之后触发卸载事件(unload)，在页面从服务器获取到需要加载的新的页面后调用，不能阻止页面的刷新和关闭。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//firefox不支持，IE和360生效，chrome系统自定义
var isSave = false;
function save() {
 alert(&#39;this is save function running.&#39;);
  isSave = true;
}
window.onbeforeunload = function () {
  console.log(&#39;this is onbeforeunload&#39;);
  if (!isSave) {
      return &#39;当前数据还没保存，关闭或刷新窗口会自动保存，是否继续？&#39;;
  } else {
      return &#39;&#39;;
  }
};
window.onunload = function () {
  if (!isSave) {
      save();
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onbeforeunload事件：在页面去服务器读取新的页面前调用，可以阻止页面的关闭和刷新，还有unload事件的执行
so:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面加载时只执行onload&lt;/li&gt;
&lt;li&gt;页面关闭时先执行onbeforeunload，最后onunload&lt;/li&gt;
&lt;li&gt;页面刷新时先执行onbeforeunload，然后onunload，最后onload。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h3 id=&#34;onscroll滚动事件&#34;&gt;onscroll滚动事件&lt;/h3&gt;

&lt;p&gt;当滚动的时候触发滚动事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.onscroll = function() {
      console.log(&amp;quot;滚动&amp;quot;);

      var h = document.documentElement.scrollTop || document.body.scrollTop;
      console.log(h);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;document.documentElement.scrollTop 和document.body.scrollTop：是用来设置滚动tiao的高度。
document.documentElement.scrollTop：IE，firefox；
document.body.scrollTop: chrome,360&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 返回页面顶部
function fun() {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;h3 id=&#34;onresize窗口变化事件&#34;&gt;onresize窗口变化事件&lt;/h3&gt;

&lt;p&gt;改变窗口尺寸时触发窗口变化事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.onresize = function() {
      console.log(&amp;quot;窗口变化&amp;quot;);

      var w = document.documentElement.clientWidth || document.body.clientWidth || window.innerWidth;

      var h = document.documentElement.clientHeight || document.body.clientHeight || window.innerHeight;

      console.log(w, h);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;键盘事件&#34;&gt;键盘事件&lt;/h1&gt;

&lt;p&gt;js中的键盘事件只有三种：keydown、keypress、keyup。触发顺序为：keydown ——&amp;gt; keypress ——&amp;gt; keyup。
当按下一个键不放开时，一般会重复触发keydown+keypress，直到放开后触发一个keyup事件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;keydown()：在键盘按下时触发&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;keypress()：在敲击按键时ch，即按下并抬起同一个按键&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;keyup()：在按键释放时触发&lt;/p&gt;

&lt;h2 id=&#34;获取键盘上的ascii码&#34;&gt;获取键盘上的ascII码&lt;/h2&gt;

&lt;p&gt;栗子：&lt;a href=&#34;https://jsfiddle.net/fz87pk7t/1/&#34;&gt;https://jsfiddle.net/fz87pk7t/1/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// 获取键码
$(document).keydown(function (event) {
    alert(event.keyCode + &#39;keydown&#39;);
});

$(document).keyup(function (event) {
    alert(event.keyCode + &#39;keyup&#39;);
});

$(document).keypress(function (event) {
    alert(event.keyCode + &#39;keypress&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字母和数字键的键码值(keyCode)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;74&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;83&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;66&lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;75&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;68&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;77&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;86&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;87&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;79&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;54&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;72&lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;81&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;82&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;数字键盘上的键的键码值(keyCode)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;健码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;健码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;104&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;97&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;105&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;98&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;106&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;99&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;107&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Enter&lt;/td&gt;
&lt;td&gt;108&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;109&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;103&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;功能键键码值(keyCode)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;健码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;健码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;F1&lt;/td&gt;
&lt;td&gt;112&lt;/td&gt;
&lt;td&gt;F7&lt;/td&gt;
&lt;td&gt;118&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F2&lt;/td&gt;
&lt;td&gt;113&lt;/td&gt;
&lt;td&gt;F8&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F3&lt;/td&gt;
&lt;td&gt;114&lt;/td&gt;
&lt;td&gt;F9&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F4&lt;/td&gt;
&lt;td&gt;115&lt;/td&gt;
&lt;td&gt;F10&lt;/td&gt;
&lt;td&gt;121&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F5&lt;/td&gt;
&lt;td&gt;116&lt;/td&gt;
&lt;td&gt;F11&lt;/td&gt;
&lt;td&gt;122&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F6&lt;/td&gt;
&lt;td&gt;117&lt;/td&gt;
&lt;td&gt;F12&lt;/td&gt;
&lt;td&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;控制键键码值(keyCode)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;键码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BackSpace&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;Esc&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;Right Arrow&lt;/td&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;td&gt;-_&lt;/td&gt;
&lt;td&gt;189&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tab&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;Spacebar&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;Down Arrow&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;.&amp;gt;&lt;/td&gt;
&lt;td&gt;190&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Clear&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;Page Up&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;Insert&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;/?&lt;/td&gt;
&lt;td&gt;191&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Enter&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;Page Down&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;td&gt;`~&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Shift&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;End&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;Num Lock&lt;/td&gt;
&lt;td&gt;144&lt;/td&gt;
&lt;td&gt;[{&lt;/td&gt;
&lt;td&gt;219&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Control&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;Home&lt;/td&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;td&gt;;:&lt;/td&gt;
&lt;td&gt;186&lt;/td&gt;
&lt;td&gt;\ |&lt;/td&gt;
&lt;td&gt;220&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Alt&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;Left Arrow&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;=+&lt;/td&gt;
&lt;td&gt;187&lt;/td&gt;
&lt;td&gt;]}&lt;/td&gt;
&lt;td&gt;221&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Cape Lock&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;Up Arrow&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;,&amp;lt;&lt;/td&gt;
&lt;td&gt;188&lt;/td&gt;
&lt;td&gt;&amp;rsquo;&amp;rdquo;&lt;/td&gt;
&lt;td&gt;222&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;三种键盘事件的区别&#34;&gt;三种键盘事件的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;keydown 和 keyup 是比较底层的事件，分别对应一个键的按下与放开，键盘上任何一个键被点按，都会触发这两个事件。&lt;/li&gt;
&lt;li&gt;keypress 更接近用户，只有可打印的字符和控制字符（如换行）被键入才触发。&lt;/li&gt;
&lt;li&gt;keydown 和 keyup 被触发后，都会产生一个虚拟键盘码，用来表示按下的是哪个键。键盘上的每个键只对应一个虚拟键盘码。keypress 被触发后产生的是实际键入的字符的 Ascll 编码，而没有对应的虚拟键盘码。这两种编码有时在数值上是相等的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;注意&#34;&gt;注意：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;keypress：只针对一些可以打印出来的字符有效，而对于功能键如F1-F12、Backspace、Enter、Escape、PageUp、PageDown和箭头方向等，就不会产生keypress事件，但是可以产生keydown、keyup事件&lt;/li&gt;
&lt;li&gt;keypress的keyCode对字母大小写敏感，而keydown和keyup不敏感；&lt;/li&gt;
&lt;li&gt;keypress事件无法区分主键盘上的数字键和副键盘数字键，而keydown和keyup的keyCode可以区分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;鼠标事件mouseevent&#34;&gt;鼠标事件MouseEvent&lt;/h1&gt;

&lt;p&gt;常见的鼠标事件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mousedown:鼠标的犍钮被按下&lt;/li&gt;
&lt;li&gt;mouseup:鼠标的犍钮被释放弹起&lt;/li&gt;
&lt;li&gt;click：单击，mousedown + mouseup =&amp;gt; click&lt;/li&gt;
&lt;li&gt;dblclick:双击，连续两次单击&lt;/li&gt;
&lt;li&gt;contextmenu:弹出右键菜单

&lt;ul&gt;
&lt;li&gt;el.contextmenu(handle)或el.on(&amp;lsquo;contextmenu&amp;rsquo;,handle)&lt;/li&gt;
&lt;li&gt;el.off(&amp;lsquo;contextmenu&amp;rsquo;),移除事件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;mouseover:鼠标移到目标上方&lt;/li&gt;
&lt;li&gt;mouseout:鼠标移出目标的上方&lt;/li&gt;
&lt;li&gt;mousemove:鼠标在目标上移动&lt;/li&gt;
&lt;li&gt;hover():鼠标指针进入和离开元素事被执行，同时绑定mouseenter和mouseleave事件，el.hover(handlerIn,handlerOut)等同于el.mouseenter(handlerIn).mouseleave(handlerOut);&lt;/li&gt;
&lt;li&gt;MouseEvent.button:返回值为数值(在DOM2.0中，W3C对鼠标事件作了现范，鼠标事件被解析为MouseEvent（我们可以用e.constructor == MouseEvent来判断其是否为鼠标事件，是左键点击还是右键点击由它的一个叫button的属性判定。以下就是W3C的标准现范：)

&lt;ul&gt;
&lt;li&gt;1：左键被按下&lt;/li&gt;
&lt;li&gt;2：中键被按下（没测出来中键）&lt;/li&gt;
&lt;li&gt;3：右键被按下&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;栗子：&lt;a href=&#34;https://jsfiddle.net/9gjz3eux/1/&#34;&gt;https://jsfiddle.net/9gjz3eux/1/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小谈javascript中this的用法</title>
      <link>http://blog.titangroupco.com/2017/03/03/%E5%B0%8F%E8%B0%88javascript%E4%B8%ADthis%E7%9A%84%E7%94%A8%E6%B3%95</link>
      <pubDate>Fri, 03 Mar 2017 09:41:07 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/03/03/%E5%B0%8F%E8%B0%88javascript%E4%B8%ADthis%E7%9A%84%E7%94%A8%E6%B3%95</guid>
      <description>&lt;h1 id=&#34;this的用法&#34;&gt;this的用法&lt;/h1&gt;

&lt;p&gt;在javascript中，因为函数的调用方式的不同，this可以是全局对象、当前对象、任意对象。&lt;/p&gt;

&lt;h2 id=&#34;1-全局中&#34;&gt;1. 全局中&lt;/h2&gt;

&lt;p&gt;在全局中（任何函数体外部），this指代全局对象，无论是否在严格模式下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在浏览器中，全局对象为window对象
console.log(this); // window

this.a = 1;
console.log(window.a); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-函数体中&#34;&gt;2. 函数体中&lt;/h2&gt;

&lt;p&gt;在函数内部，函数的调用方式决定了this的值&lt;/p&gt;

&lt;h3 id=&#34;2-1-直接调用&#34;&gt;2.1 直接调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;非严格模式下：
function f1() {
    return this;
}

f1(); // window

严格模式下：
function f2() {
    &amp;quot;use strict&amp;quot;;
    return this;
}

f2(); // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-对象方法中的this&#34;&gt;2.2 对象方法中的this&lt;/h3&gt;

&lt;p&gt;当以对象的方法的方式调用函数时，函数内的this指调用该函数的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    age: 25,
    fun: function() {
        return this.age;
    }
};

console.log(obj.fun()); // 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this的绑定只受最靠近的成员引用的影响&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {age: 24};
function fun1(){
    return this.age;
}

obj.fun = fun1;
console.log(obj.fun()); // 24

obj.b = {
    f: fun1,
    age: 18
};
console.log(obj.b.f()); // 18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1). 原型链中的this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    fun: function() {
        return this.a + this.b;
    }
};
var p = new Object(obj);
p.a = 1;
p.b = 2;
console.log(p.fun()); // 3 对象p的fun属性继承自它的原型，但是因为fun是作为p的方法调用的，所以它的this指向了p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2). getter与setter中的this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f1() {
    return this.a*this.a + this.b * this.b;
}
var obj = {
    a: 1,
    b: 2,
    get f2() {
        return this.a+this.b;
    }
};
Object.defineProperty(obj, &#39;f1&#39;, {
    get: f1, enumerable:true,configurable:true
});

console.log(obj.f1, obj.f2); // 5   3  作为getter或setter函数都会绑定 this 到从设置属性或得到属性的那个对象。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-构造函数中的this&#34;&gt;2.3 构造函数中的this&lt;/h3&gt;

&lt;p&gt;当一个函数被作为一个构造函数来使用（使用new关键字），它的this与即将被创建的新对象绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f1() {
    this.a = 1;
}

var obj = new f1();
console.log(obj.a); // 1

function f2() {
    this.a = 2;
    return {a: 3};
}

obj = new f2();
console.log(obj.a); // 3  因为手动设置了返回对象，所以this.a=2虽然执行了，但是对外部没有任何影响
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-call和apply&#34;&gt;2.4 call和apply&lt;/h3&gt;

&lt;p&gt;每个函数都包含两个非继承而来的方法：call()和apply()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。也就是说，直接调用函数，调用时指定执行环境是谁.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.age = 1;
var obj = {age: 2};

function sayAge() {
    console.log(this.age);
}

sayAge.call(this); // 1
sayAge.call(window); // 1
sayAge.call(obj); // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apply方法接收两个参数，第一个参数是在函数中运行函数的作用域，另一个参数是数组。
call方法与apply相比较，第一个参数相同，用于指定函数运行的作用域，其余参数直接传递给函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add(c, d) {
    return this.a + this.b + c + d;
}

var obj = {a: 1, b: 2};
add.call(obj, 3, 4); // 1+2+3+4 = 10
add.apply(obj, [3,4]); // 1+2+3+4 = 10

注意： 使用call和apply时，如果传递的this值不是yijavascript会默认使用ToObject将其转换为对象

function bar() {
    console.log(this);
}

bar.call(7); // number
bar.call(&#39;fun&#39;); // string
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-bind方法&#34;&gt;2.5 bind方法&lt;/h3&gt;

&lt;p&gt;ECMAScript 5 引入了 Function.prototype.bind。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f() {
    return this.a;
}

var g=f.bind({a: &#39;jing&#39;});
console.log(g()); // jing

var obj = {
    a: liu,
    f: f,
    g: g
}

console.log(obj.f()); // liu
console.log(obj.g()); // jing
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-6-dom事件处理函数中的this&#34;&gt;2.6 DOM事件处理函数中的this&lt;/h3&gt;

&lt;p&gt;当函数被用作事件处理函数时，它的this指向触发事件的元素,例子：&lt;a href=&#34;https://jsfiddle.net/3urqmtb0/&#34;&gt;https://jsfiddle.net/3urqmtb0/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
   &amp;lt;body&amp;gt;
      &amp;lt;button&amp;gt;btn1&amp;lt;/button&amp;gt;
      &amp;lt;button&amp;gt;btn2&amp;lt;/button&amp;gt;
      &amp;lt;button&amp;gt;btn3&amp;lt;/button&amp;gt;
   &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
 // 点击当前元素，元素背景色变为粉色
&amp;lt;script&amp;gt;
    function pinkify(event) {
        console.log(this === event.currentTarget);
        console.log(this);
        this.style.backgroundColor = &#39;pink&#39;;
    }
    var elements = document.getElementsByTagName(&#39;button&#39;);

    for(var i=0; i&amp;lt;elements.length; i++) {
        elements[i].addEventListener(&#39;click&#39;, pinkify, false);
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-7-内联事件处理函数中的this&#34;&gt;2.7 内联事件处理函数中的this&lt;/h3&gt;

&lt;p&gt;当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素，例子：&lt;a href=&#34;https://jsfiddle.net/ak7sscuL/&#34;&gt;https://jsfiddle.net/ak7sscuL/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button onclick=&amp;quot;alert(this.tagName.toLowerCase());&amp;quot;&amp;gt;
  Show this
&amp;lt;/button&amp;gt;
// alert button

&amp;lt;button onclick=&amp;quot;alert((function(){return this})());&amp;quot;&amp;gt;
  Show inner this
&amp;lt;/button&amp;gt;
// alert [Object Window]  没有设置内部函数的 this，所以它指向 global/window 对象
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>D3 入门教程</title>
      <link>http://blog.titangroupco.com/2017/01/24/d3-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B</link>
      <pubDate>Tue, 24 Jan 2017 16:50:51 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/01/24/d3-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B</guid>
      <description>&lt;h1 id=&#34;1-数据可视化&#34;&gt;1. 数据可视化&lt;/h1&gt;

&lt;p&gt;数据可视化，是关于数据视觉表现形式的科学技术研究。为了使复杂的数据和文字变得更容易理解，各种可视化工具因此诞生，其中D3 正是其中的佼佼者。
&lt;img src=&#34;http://www.ourd3js.com/wordpress/wp-content/uploads/2014/06/14.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-d3-简介&#34;&gt;2. D3 简介&lt;/h1&gt;

&lt;p&gt;D3 的全称是（Data-Driven Documents），字面意思是一个被数据驱动的文档。听名字有点抽象，说简单一点，其实就是一个 JavaScript 的函数库，使用它主要是用来做数据可视化的。&lt;/p&gt;

&lt;h1 id=&#34;3-基本用法&#34;&gt;3. 基本用法&lt;/h1&gt;

&lt;h2 id=&#34;3-1-选择元素&#34;&gt;3.1 选择元素&lt;/h2&gt;

&lt;p&gt;在 D3 中，用于选择元素的函数有两个，函数接收符合CSS选择器条件的字符串：
- d3.select()：是选择所有指定元素的第一个
- d3.selectAll()：是选择指定元素的全部&lt;/p&gt;

&lt;p&gt;这两个函数返回的结果称为选择集。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-2-绑定数据&#34;&gt;3.2 绑定数据&lt;/h2&gt;

&lt;p&gt;D3 有一个很独特的功能：能将数据绑定到 DOM 上，绑定之后，当需要依靠这个数据才操作元素的时候，会很方便。&lt;/p&gt;

&lt;p&gt;D3 中是通过以下两个函数来绑定数据的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;datum()：绑定一个数据到选择集上&lt;/li&gt;
&lt;li&gt;data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相对而言，data() 比较常用。&lt;/p&gt;

&lt;h2 id=&#34;3-3-插入元素&#34;&gt;3.3 插入元素&lt;/h2&gt;

&lt;p&gt;插入元素涉及的函数有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;append()：在选择集末尾插入元素&lt;/li&gt;
&lt;li&gt;insert()：在选择集前面插入元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-4-删除元素&#34;&gt;3.4 删除元素&lt;/h2&gt;

&lt;p&gt;对于选择的元素，使用remove()函数&lt;/p&gt;

&lt;h2 id=&#34;3-5-比例尺&#34;&gt;3.5 比例尺&lt;/h2&gt;

&lt;p&gt;将某一区域的值映射到另一区域，其大小关系不变。&lt;/p&gt;

&lt;p&gt;比例尺，很像数学中的函数。例如，对于一个一元二次函数，有 x 和 y 两个未知数，当 x 的值确定时，y 的值也就确定了。&lt;/p&gt;

&lt;p&gt;在数学中，x 的范围被称为定义域，y 的范围被称为值域。&lt;/p&gt;

&lt;p&gt;D3 中的比例尺，也有定义域和值域，分别被称为 domain 和 range。开发者需要指定 domain 和 range 的范围，如此即可得到一个计算关系。&lt;/p&gt;

&lt;p&gt;D3 提供了多种比例尺，常用的有以下两种：
- d3.scale.linear()：返回一个线性的比例尺，能将一个连续的区间，映射到另一区间。
- d3.scale.ordinal()：返回一个序数比例尺，即定义域和值域是离散的。&lt;/p&gt;

&lt;h2 id=&#34;3-6-坐标轴&#34;&gt;3.6 坐标轴&lt;/h2&gt;

&lt;p&gt;坐标轴，是可视化图表中经常出现的一种图形，由一些列线段和刻度组成。在D3 中使用d3.svg.axis()，能够在 SVG 中生成组成坐标轴的元素。&lt;/p&gt;

&lt;h1 id=&#34;4-实现一个简单的柱形图&#34;&gt;4. 实现一个简单的柱形图&lt;/h1&gt;

&lt;p&gt;一个完整的柱形图包含三部分：矩形、文字、坐标轴。基于D3 的基本用法，制作一个简单的柱形图，内容包括：选择集、数据绑定、比例尺、坐标轴等内容。&lt;/p&gt;

&lt;h2 id=&#34;4-1-添加-svg-画布&#34;&gt;4.1 添加 SVG 画布&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//画布大小
var width = 400;
var height = 400;

//在 body 里添加一个 SVG 画布   
var svg = d3.select(&amp;quot;body&amp;quot;)
    .append(&amp;quot;svg&amp;quot;)
    .attr(&amp;quot;width&amp;quot;, width)
    .attr(&amp;quot;height&amp;quot;, height);

//画布周边的空白
 var padding = {left:30, right:30, top:20, bottom:20};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了一个 padding，是为了给 SVG 的周边留一个空白，最好不要将图形绘制到边界上。&lt;/p&gt;

&lt;h2 id=&#34;4-2-定义数据和比例尺&#34;&gt;4.2 定义数据和比例尺&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//定义一个数组
var dataset = [10, 20, 30, 40, 33, 24, 12, 5];

//x轴的比例尺
var xScale = d3.scale.ordinal()
    .domain(d3.range(dataset.length))
    .rangeRoundBands([0, width - padding.left - padding.right]);

//y轴的比例尺
var yScale = d3.scale.linear()
    .domain([0,d3.max(dataset)])
    .range([height - padding.top - padding.bottom, 0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x 轴使用序数比例尺，y 轴使用线性比例尺。要注意两个比例尺值域的范围。&lt;/p&gt;

&lt;h2 id=&#34;4-3-定义坐标轴&#34;&gt;4.3 定义坐标轴&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//定义x轴
var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient(&amp;quot;bottom&amp;quot;);

//定义y轴
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient(&amp;quot;left&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x 轴刻度的方向向下，y 轴的向左。&lt;/p&gt;

&lt;h2 id=&#34;4-4-添加矩形和文字元素&#34;&gt;4.4 添加矩形和文字元素&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//矩形之间的空白
var rectPadding = 4;

//添加矩形元素
var rects = svg.selectAll(&amp;quot;.MyRect&amp;quot;)
        .data(dataset)
        .enter()
        .append(&amp;quot;rect&amp;quot;)
        .attr(&amp;quot;class&amp;quot;,&amp;quot;MyRect&amp;quot;)
        .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + padding.top + &amp;quot;)&amp;quot;)
        .attr(&amp;quot;x&amp;quot;, function(d,i){
            return xScale(i) + rectPadding/2;
        } )
        .attr(&amp;quot;y&amp;quot;,function(d){
            return yScale(d);
        })
        .attr(&amp;quot;width&amp;quot;, xScale.rangeBand() - rectPadding )
        .attr(&amp;quot;height&amp;quot;, function(d){
            return height - padding.top - padding.bottom - yScale(d);
        });

//添加文字元素
var texts = svg.selectAll(&amp;quot;.MyText&amp;quot;)
        .data(dataset)
        .enter()
        .append(&amp;quot;text&amp;quot;)
        .attr(&amp;quot;class&amp;quot;,&amp;quot;MyText&amp;quot;)
        .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + padding.top + &amp;quot;)&amp;quot;)
        .attr(&amp;quot;x&amp;quot;, function(d,i){
            return xScale(i) + rectPadding/2;
        } )
        .attr(&amp;quot;y&amp;quot;,function(d){
            return yScale(d);
        })
        .attr(&amp;quot;dx&amp;quot;,function(){
            return (xScale.rangeBand() - rectPadding)/2;
        })
        .attr(&amp;quot;dy&amp;quot;,function(d){
            return 20;
        })
        .text(function(d){
            return d;
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;矩形元素和文字元素的 x 和 y 坐标要特别注意，要结合比例尺给予适当的值。&lt;/p&gt;

&lt;h2 id=&#34;4-5-添加坐标轴的元素&#34;&gt;4.5 添加坐标轴的元素&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//添加x轴
svg.append(&amp;quot;g&amp;quot;)
  .attr(&amp;quot;class&amp;quot;,&amp;quot;axis&amp;quot;)
  .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + (height - padding.bottom) + &amp;quot;)&amp;quot;)
  .call(xAxis);

//添加y轴
svg.append(&amp;quot;g&amp;quot;)
  .attr(&amp;quot;class&amp;quot;,&amp;quot;axis&amp;quot;)
  .attr(&amp;quot;transform&amp;quot;,&amp;quot;translate(&amp;quot; + padding.left + &amp;quot;,&amp;quot; + padding.top + &amp;quot;)&amp;quot;)
  .call(yAxis);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-6-完整效果图&#34;&gt;4.6 完整效果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.ourd3js.com/wordpress/wp-content/uploads/2014/06/5111.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;5-结语&#34;&gt;5. 结语&lt;/h1&gt;

&lt;p&gt;使用D3 可以方便的实现各种可视化效果，它与其他可视化工具的主要区别如下：
&lt;img src=&#34;http://wiki.jikexueyuan.com/project/d3wiki/images/layout-2.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择 D3：如果希望开发脑海中任意想象到的图表；&lt;/li&gt;
&lt;li&gt;选择 Highcharts、Echarts 等：如果希望开发几种固定种类的、十分大众化的图表。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>前端使用websocket的问题</title>
      <link>http://blog.titangroupco.com/2017/01/22/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8websocket%E7%9A%84%E9%97%AE%E9%A2%98</link>
      <pubDate>Sun, 22 Jan 2017 18:11:48 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/01/22/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8websocket%E7%9A%84%E9%97%AE%E9%A2%98</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;websocket相关概念&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&#34;&gt;websocket&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。
IE10以上才支持HTML5，才支持websocket，chrome，火狐，opera等浏览器支持较好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://socket.io/&#34;&gt;Socket.IO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了&lt;strong&gt;客户端的JavaScript&lt;/strong&gt;和&lt;strong&gt;服务器端的Node.js&lt;/strong&gt;。
Socket.IO是一个跨平台，支持多种连接方式，如websocket，flashsocket,ajax等，如果客户端不支持websocket时，可以切换使用其他链接方式，比如ajax轮询等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;/lib/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
   var socket = io();
   socket.on(&#39;connect&#39;, function() {
           /* 具体操作 */
   });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最近笔者新参与的一个web项目，拟定采用vue2.0来编写，期间遇到有关使用websocket的问题，记录一下，个中遇到的一些问题和解决方法，分享给有需要的人。&lt;/p&gt;

&lt;p&gt;当前服务端采用了websocket的方式，这需要客户端也相应的采用websocket来与客户端建立ws连接，这样客户端和服务端就可以双向的发送数据。笔者当时一拿到这个就会觉得是不是又需要npm安装什么包似的，因为这个功能是从另一个项目（暂且称其为项目B）的功能迁移过来的，而项目B前端是用的angularjs开发的，前端直接用的angularjs的一个websocket的包（angular-websocke），然后几行代码就敲定了，创建连接，发送数据，接收数据，很是方便。当前项目采用的是vue框架，很自然的就去搜有木有vue的websocket包，很快找到了vue-websocket，安装好后，调试，直接报错：
　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=polling&amp;amp;t=LbjddEK. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://localhost:8080&#39; is therefore not allowed access. The response had HTTP status code 404.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;笔者对比了项目B，同样在客户端启动本地server，能正常创建到服务端的ws连接，不会像http请求一样有跨域的问题，同时另一问题就是，明明是要创建ws连接，为何浏览器的控制台里会提示是http的连接？vue-websocket没有调试成功，马上去找找有没有通用的包，于是在github找了js相关的websocket的相关包，比如ws，笔者对照了angularjs-websocket包，它也是依赖的ws。于是按照ws的说明文档，安装，然后webpack直接报错了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR in ./~/ws/lib/WebSocketServer.js
Module not found: Error: Cannot resolve module &#39;tls&#39; in xx\node_modules\ws\lib
@ ./~/ws/lib/WebSocketServer.js 15:10-24
ERROR in ./~/options/lib/options.js
Module not found: Error: Cannot resolve module &#39;fs&#39; in xx\node_modules\options\lib
@ ./~/options/lib/options.js 6:9-22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找资料，说是这两个包是服务端node用的，客户端没有所以导致报错，需要修改webpack的配置文件，使其不加载客户端不需要的包
&lt;a href=&#34;https://github.com/webpack/react-starter/issues/3#issuecomment-53395089&#34;&gt;https://github.com/webpack/react-starter/issues/3#issuecomment-53395089&lt;/a&gt;
然后，webpack不报错了，但是前端调用ws生成实例的时候，依然会报错，因为ws链接创建的时候，先发起了http的链接请求，按照ws文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var WebSocket = require(&#39;ws&#39;)
var ws = new WebSocket(&#39;ws://xxx/ws&#39;, &#39;ws&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码里，生成ws实例的时候，还是会产生http的链接，跟前面用vue-websocket的情况类似，因为是在本地启动的前端服务，所以这样发起到服务器的请求，会导致跨越报错。奇怪的是项目B里的angular使用的angular-websocket包，同样是基于ws包做的，在本地启动，是直接创建的ws链接，没有跨越的问题。然后在vue论坛上查找相关资料，类似的问题比如：&lt;a href=&#34;https://forum-archive.vuejs.org/topic/1293/webpack-bundling-issue-with-websockets/3&#34;&gt;https://forum-archive.vuejs.org/topic/1293/webpack-bundling-issue-with-websockets/3&lt;/a&gt;
有人提到：Can&amp;rsquo;t you just use window.WebSocket instead of ws?
提醒到了我，我摒弃了ws，直接用window.WebSocket，来创建ws连接，果然成功了。那为啥angular-websocket基于ws，能正常在浏览器执行，vue这边直接用ws不行，于是去查看angular-websocket的源码，才发现angular-websocket基于ws做了封装，它提供的$websocket对象，在当前浏览器环境下，本质上也是window.WebSocket的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import angular from &#39;angular&#39;;
var Socket;
if (typeof window === &#39;undefined&#39;) {
try {
var ws = require(&#39;ws&#39;);
Socket = (ws.Client||ws.client||ws);
} catch(e) {}
}
// Browser
Socket = (Socket || window.WebSocket || window.MozWebSocket);
////////////////////////////////////////////////////////////
function $WebSocketBackendProvider($log) {
this.create = function create(url, protocols) {
var match = /wss?:\/\//.exec(url);
if (!match) {
throw new Error(&#39;Invalid url provided&#39;);
}
if (protocols) {
return new Socket(url, protocols);
}
return new Socket(url);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看源码里面，angular-websocket也是用window.WebSocket创建的，只有在没有window对象的时候，才会基于ws包来创建websocket对象。然后瞬间感觉找准了方向，目前我们的场景主要是PC端的浏览器使用，可以直接用window.WebSocket对象来，于是查阅了&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&#34;&gt;window.WebSocket的文档&lt;/a&gt;，很快问题就解决了，原来自带的window对象就已经可以解决问题了，自己绕了一大圈，还是回到原点，细看了它文档里写的相关方法，确实和前面讲到的angular-websocket很像，确实angular-websocket是对这些方法，比如onopen，send，onmessange等方法进行了封装，让开发可以更方便的调用。&lt;/p&gt;

&lt;p&gt;另外，文章最前面提到的&lt;a href=&#34;http://socket.io/&#34;&gt;Socket.IO&lt;/a&gt;，笔者在客户端安装了Socket.IO，并且按照文档说明，去建立ws链接，发现以下问题：&lt;/p&gt;

&lt;h4 id=&#34;1-安装socket-io-client-安装完之后-webpack报错&#34;&gt;1、安装socket.io-client，安装完之后，webpack报错&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;ERROR in ./~/socket.io-client/~/component-emitter/index.js
Module build failed: Error: ENOENT: no such file or directory, open &#39;xx\node_modules\socket.io-client\node_modules\component-emitter\index.js&#39;
    at Error (native)
 @ ./~/socket.io-client/lib/manager.js 8:14-42
ERROR in ./~/engine.io-client/~/component-emitter/index.js
Module build failed: Error: ENOENT: no such file or directory, open &#39;xx\node_modules\engine.io-client\node_modules\component-emitter\index.js&#39;
    at Error (native)
 @ ./~/engine.io-client/lib/socket.js 6:14-42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;https://github.com/socketio/socket.io-client/issues/933&#34;&gt;https://github.com/socketio/socket.io-client/issues/933&lt;/a&gt;这个需要修改一下webpack的配置文件，添加以下两行后，webpack可以打包通过。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module: {
    noParse: [&#39;ws&#39;]
  },
  externals: [&#39;ws&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-创建连接报错&#34;&gt;2、创建连接报错&lt;/h4&gt;

&lt;p&gt;创建连接&lt;code&gt;var socket = io(url);&lt;/code&gt;，这样创建的链接，Socket.IO默认是按轮询方式发起的http请求（很奇怪，当前浏览器明明是支持websocket的），这样首先就出现了前面的http跨域请求报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=polling&amp;amp;t=LbjddEK. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://localhost:8080&#39; is therefore not allowed access. The response had HTTP status code 404.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查阅资料，创建连接的时候，可以指定参数&lt;code&gt;io(WS_URL, {transports: [&#39;websocket&#39;, &#39;polling&#39;, &#39;flashsocket&#39;]})&lt;/code&gt;，设置其发起websocket链接，这样在console里看到的确实是发起的ws请求，然而依然报404错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WebSocket connection to &#39;ws://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=websocket&#39; failed: Error during WebSocket handshake: Unexpected response code: 404
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示是404找不到，确实是服务端没有&lt;code&gt;&#39;ws://192.168.0.239:9000/socket.io/?EIO=3&amp;amp;transport=websocket&#39;&lt;/code&gt;这样的url，这种url是默认的ws服务端的url，可以设置 path，path默认是&lt;code&gt;/socket.io&lt;/code&gt;，设置path后，&lt;code&gt;io(WS_URL, {path: &#39;/ws&#39;, transports: [&#39;websocket&#39;, &#39;polling&#39;, &#39;flashsocket&#39;]})&lt;/code&gt;，依然报301错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WebSocket connection to &#39;ws://192.168.0.239:9000/ws/?EIO=3&amp;amp;transport=websocket&#39; failed: Error during WebSocket handshake: Unexpected response code: 301
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;笔者对比了成功建立ws链接时的url，&lt;code&gt;ws://192.168.0.239:9000/ws&lt;/code&gt;，然后用工具测试了下，只有path是&lt;code&gt;/ws&lt;/code&gt;，即ws://192.168.0.239:9000/ws?EIO=3&amp;amp;transport=websocket&lt;code&gt;这样的url才能成功建立ws链接，这里报301的错误，是因为socketio会在path后面添加&lt;/code&gt;/?EIO=3&amp;amp;transport=websocket`这样一串参数，这样导致了服务端路由匹配不上，导致出现了404或301的情况，所以这里需要服务端配合调整一下路由规则，即可。&lt;/p&gt;

&lt;p&gt;最终，结合当前的实际情况还是采用了原生的websocket，Socket.IO对url的格式有一定的规范要求，目前查阅了socketio的相关api文档，尚未找到可以自定义url格式的方法，比较适合客户端和服务端都同时可控的情况。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Javascript Prototype</title>
      <link>http://blog.titangroupco.com/2017/01/05/javascript-prototype</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2017/01/05/javascript-prototype</guid>
      <description>&lt;p&gt;&lt;em&gt;note of &lt;a href=&#34;https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes&#34;&gt;You Don&amp;rsquo;t know JS&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;data-types-in-javascript&#34;&gt;Data types in Javascript&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Javascript has 6 primitive data(immutable) types
typeof 3.14  // &#39;number&#39;;
typeof &#39;bla&#39;  // &#39;string&#39;;
typeof true  // &#39;boolean&#39;
typeof Symbol.iterator  // &#39;symbol&#39;
typeof undefined  // &#39;undefined&#39;
typeof null  // &#39;object&#39;

// and object
typeof {a:1}  // &#39;object&#39;
typeof function fn(){}  // &#39;function&#39;, it&#39;s in fact an object with special type tag


// object has sub type
Object.prototype.toString.call(fn)  // &#39;[object Function]&#39;

// primitive types have object equivalent that wrap around them.
Object.prototype.toString.call(3.14)  // &#39;[object Number]&#39;
Object.prototype.toString.call(&#39;bla&#39;)  // &#39;[object String]&#39;
Object.prototype.toString.call(true)  // &#39;[object Boolean]&#39;
Object.prototype.toString.call(Symbol.iterator)  // &#39;[object Symbol]&#39;

Object.prototype.toString.call({})  // &#39;[object Object]&#39;
Object.prototype.toString.call([])  // &#39;[object Array]&#39;
Object.prototype.toString.call(/[a-zA-Z]+/)  // &#39;[object RegExp]&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;null&lt;/code&gt; is not an object for it has no any property.&lt;/p&gt;

&lt;p&gt;for why &lt;code&gt;typeof null === &#39;object&#39;&lt;/code&gt; see details &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;object-property&#34;&gt;Object property&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var myObject = {
    a: 2
};

// `in` operator will check upwards the whole prototype chain
(&#39;a&#39; in myObject) // true
(&#39;toString&#39; in myObject) // true
// `hasOwnProperty` function check only `this` object
(myObject.hasOwnProperty(&#39;toString&#39;))  // false

// property has characteristics decribed by sth called `descriptor`
Object.getOwnPropertyDescriptor( myObject, &amp;quot;a&amp;quot; );
// {
//    value: 2,
//    writable: true,
//    enumerable: true,
//    configurable: true
// }

// another way to define property
Object.defineProperty( myObject, &amp;quot;a&amp;quot;, {
    value: 2,
    writable: true,
    configurable: true,
    enumerable: true
} );

// prevent an object from having new properties added to it
Object.preventExtensions( myObject );

Object.seal(..) 
// Object.preventExtensions(..) + marks all its existing properties as configurable:false.

Object.freeze(..)
// Object.seal(..) + marks all &amp;quot;data accessor&amp;quot; properties as writable:false

// descriptor includes data descriptor and accessor descriptor
Object.defineProperty(
    myObject,   // target
    &amp;quot;b&amp;quot;,        // property name
    {           // descriptor
        // define a getter for `b`
        get: function(){ return this.a * 2 },

        // make sure `b` shows up as an object property
        enumerable: true
    }
);

myObject.b;  // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;what-is-this&#34;&gt;What is &lt;code&gt;this&lt;/code&gt;?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function dcyy() {
  console.log(this.name, &#39;到此一游 :(&#39;);
}
var name = &#39;global&#39;;
var zs = {
  name: &#39;张三&#39;,
  dcyy
}
var ls = {
  name: &#39;李四&#39;
}

dcyy();  // global 到此一游 :(
zs.dcyy();  // &#39;张三 到此一游 :(
dcyy.call(ls);  // 李四 到此一游 :(
new dcyy();
// undefined &#39;到此一游 :(&#39;
// dcyy {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;this&lt;/code&gt; is not an author-time binding but a runtime binding.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Called with new? Use the newly constructed object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Called with &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; (or &lt;code&gt;bind&lt;/code&gt;)? Use the specified object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Called with a context object owning the call? Use that context object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Default: undefined in strict mode, global object otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;prototype-chain&#34;&gt;Prototype Chain&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Foo() {
    // ...
}

var a = new Foo();

Object.getPrototypeOf( a ) === Foo.prototype; // true

a.__proto__ === Foo.prototype;  // true

Foo.prototype.isPrototypeOf(a);  // true

var p = {
    sayHi: function () {
        console.log(&#39;hi!&#39;);
    }
}
var c = Object.create(p);
c.sayHi();  // &#39;hi!&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, when u create an object use &lt;code&gt;new&lt;/code&gt; operator and a function say &lt;em&gt;fn&lt;/em&gt;, the prototype of this created object is &lt;code&gt;fn.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;You Dont Know JS&lt;/code&gt; advocates prototype pattern which is the foundation of JS, objects OO simulation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduction to Vue</title>
      <link>http://blog.titangroupco.com/2016/10/31/introduction-to-vue</link>
      <pubDate>Mon, 31 Oct 2016 08:42:14 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2016/10/31/introduction-to-vue</guid>
      <description>&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
  {{ message }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var app = new Vue({
  el: &#39;#app&#39;,
  data: {
    message: &#39;Hello Vue!&#39;
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Vue inherits a lot from angular. Both has concept of &lt;code&gt;directives&lt;/code&gt; and &lt;code&gt;components&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We will skip those similarities, but focus on differences here.&lt;/p&gt;

&lt;h3 id=&#34;directive-has-modifier-and-arguments&#34;&gt;Directive has Modifier and Arguments&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input v-model.number=&amp;quot;age&amp;quot; type=&amp;quot;number&amp;quot;&amp;gt;
&amp;lt;a v-bind:href=&amp;quot;url&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way.&lt;/li&gt;
&lt;li&gt;Some directives can take an “argument”, denoted by a colon after the directive name.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;component-has-slots&#34;&gt;Component has slots&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://p1.bpimg.com/567571/d8c7009a5bc6f77a.jpg&#34; alt=&#34;slot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The API for a Vue component comes in three parts - props, events, and slots:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Props allow the external environment to pass data into the component&lt;/li&gt;
&lt;li&gt;Events allow the component to trigger side effects in the external environment&lt;/li&gt;
&lt;li&gt;Slots allow the external environment to compose the component with extra content.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;my-component
  v-bind:foo=&amp;quot;baz&amp;quot;
  v-bind:bar=&amp;quot;qux&amp;quot;
  v-on:event-a=&amp;quot;doThis&amp;quot;
  v-on:event-b=&amp;quot;doThat&amp;quot;
&amp;gt;
  &amp;lt;img slot=&amp;quot;icon&amp;quot; src=&amp;quot;...&amp;quot;&amp;gt;
  &amp;lt;p slot=&amp;quot;main-text&amp;quot;&amp;gt;Hello!&amp;lt;/p&amp;gt;
&amp;lt;/my-component&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vue-ecosystem&#34;&gt;Vue Ecosystem&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://router.vuejs.org/&#34;&gt;vue-router&lt;/a&gt; is officially-supported&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://vuex.vuejs.org/&#34;&gt;vuex&lt;/a&gt; is a state management pattern + library for Vue.js applications.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;comparison&#34;&gt;Comparison&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metric&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Angular&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Angular 2&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;React&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Vue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Star(Github)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;53015&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;17748&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;52844&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;32113&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Fork(Github)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;26177&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4525&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9306&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3645&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Issue(on/off)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;sup&gt;674&lt;/sup&gt;&amp;frasl;&lt;sub&gt;7460&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;sup&gt;811&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6964&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;sup&gt;484&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3336&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;&lt;sup&gt;66&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3069&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Size&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;156K&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;636K&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;150K&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64K&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LOC(TodoMVC)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;442&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;198&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;520&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;221&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Size(TodoMVC)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.1M&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.6M&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2M&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;294K&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;created on 10/31/2016&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Angular 2 requires Typescript while others require Javascript.&lt;/li&gt;
&lt;li&gt;Angular 2, React and Vue support cross-platform programming.&lt;/li&gt;
&lt;li&gt;Angular offer more features. But React and Vue get enhancement from
additional libraries, which is authored and supported by community.&lt;/li&gt;
&lt;li&gt;From the metric above, Vue has the smallest community.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://vuejs.org/guide/comparison.html&#34;&gt;Read more&lt;/a&gt; on differences among these front-end Javascript frameworks.&lt;/p&gt;

&lt;p&gt;You can use &lt;a href=&#34;https://github.com/vuejs/vue-cli&#34;&gt;vue-cli&lt;/a&gt; to scaffold Vue.js projects.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Webpack</title>
      <link>http://blog.titangroupco.com/2016/10/28/webpack</link>
      <pubDate>Fri, 28 Oct 2016 08:42:14 +0800</pubDate>
      
      <guid>http://blog.titangroupco.com/2016/10/28/webpack</guid>
      <description>&lt;h2 id=&#34;motivation-or-problems&#34;&gt;Motivation or Problems&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There are multiple standards of module system in JS world including CommonJS, AMD, ES6 modules and &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag style.&lt;/li&gt;
&lt;li&gt;There are two extremes when transferring modules

&lt;ol&gt;
&lt;li&gt;one request per module&lt;/li&gt;
&lt;li&gt;All modules in one request&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Why should a module system only help the developer with JavaScript?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;io&#34;&gt;IO&lt;/h2&gt;

&lt;p&gt;Webpack is a module bundler.&lt;/p&gt;

&lt;p&gt;It takes a bunch of files, treating each as a module, figuring out the dependencies between them, and bundle them into static assets that are ready for deployment.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dtinth.github.io/webpack-docs-images/usage/how-it-works.png&#34; alt=&#34;what webpack does&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;some-concepts-of-webpack&#34;&gt;Some concepts of Webpack&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;chunk: A batch of modules that bundled into one single file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;loader: Transformations that are applied on a resource file(module) of your app.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugin: Add functionality typically related to bundles in webpack.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;some-plugins&#34;&gt;Some plugins&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DefinePlugin: Allows you to create global constants which can be configured at compile time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HotModuleReplacementPlugin: Enables Hot Module Replacement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HtmlWebpackPlugin: Generates a solid base html page for your web application with all your webpack generated css and js files built in.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CommonsChunkPlugin: Generate an extra chunk, which contains common modules shared between entry points.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UglifyJsPlugin: Minimize all JavaScript output of chunks.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ExtractTextPlugin: Extract text from bundle into a file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-of-webpack-configuration&#34;&gt;Example of Webpack configuration&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;notice comments start with hash character&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  module: {
    ...
    loaders: [
      # They are functions that take the source of a resource file as the parameter
      # and return the new source.
      { test: /\.less$/,
        loader: &#39;css-loader!less-loader&#39; },
      { test: /\.js$/,
        loader: &#39;babel&#39;,
        include: &#39;/path-to-your-project/vue-webpack&#39;,
        exclude: /node_modules/ },
      ...
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>